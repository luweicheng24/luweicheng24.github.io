<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芦苇</title>
  <subtitle>芦苇的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luweicheng24.github.io/"/>
  <updated>2017-08-21T06:25:28.752Z</updated>
  <id>https://luweicheng24.github.io/</id>
  
  <author>
    <name>luweicheng24</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>踩黑块</title>
    <link href="https://luweicheng24.github.io/2017/08/21/%E8%B8%A9%E9%BB%91%E5%9D%97/"/>
    <id>https://luweicheng24.github.io/2017/08/21/踩黑块/</id>
    <published>2017-08-21T06:12:29.000Z</published>
    <updated>2017-08-21T06:25:28.752Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章通过自定义ViewGroup实现前段时间挺火的一个游戏——别踩白块。好了先看一下效果图：</p>
<p><img src="http://img.blog.csdn.net/20170503141750007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHV3ZWljaGVuZzI0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<a id="more"></a>
<p>好了，下面我说一下我的思路，大家都知道重写ViewGroup的步骤：onMesure()，onDraw( ),onLayout(),这里我只需要重写onDraw（）和onTouchEvent（）；好了，我首先创建的一个矩形类继承RectF类，创建了误了静态常量和两个构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">import android.graphics.RectF;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Author   : luweicheng on 2017/4/30 0030 12:16</div><div class="line"> * E-mail   ：1769005961@qq.com</div><div class="line"> * GitHub   : https://github.com/luweicheng24</div><div class="line"> * funcation: 矩形框类</div><div class="line"> */</div><div class="line"></div><div class="line">public class PiecesRectF extends RectF &#123;</div><div class="line"></div><div class="line">    private int type;</div><div class="line"></div><div class="line">    public final static int BLAKE = 0;//黑块</div><div class="line">    public final static int WRITE = 1;//白块</div><div class="line">    public final static int BLUE = 2;//黑块按下时的显示蓝块</div><div class="line">    public final static int START = 3;//标记有开始的黑块</div><div class="line">    public final static int RED = 4;//按到白块，或有黑块漏按，游戏结束时的红块</div><div class="line"></div><div class="line">    public PiecesRectF()&#123;</div><div class="line">        super();</div><div class="line">        type = Math.random() &gt; 0.5 ? 0:1;//初始化时，给type随机一个白块或黑块</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 创建最后一行的矩形</div><div class="line">     * @param isLast</div><div class="line">     */</div><div class="line">    public PiecesRectF(Boolean isLast)&#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line">    public void setType(int type) &#123;</div><div class="line">        this.type = type;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public int getType() &#123;</div><div class="line">        return type;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该类对象就想到于每个矩形框，类型有五种类型，注释也已经写的很清楚了。下面我们就来继承ViewGroup来自定义我们的ViewGroup：继承之后我们先来对初始化五行四列的二维数组来存放矩形框,由于第五行的矩形框要作为开始按钮，所以单独创建了第五行，第五行只有一个类型的开始的矩形框，其他的都是类型为白色的矩形框：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 初始化5行4列的矩形框</div><div class="line">     */</div><div class="line">    private void initRect() &#123;</div><div class="line">        /**</div><div class="line">         * 创建4行4列的方块(每行1,2列最少有一个黑块，3,4列最少有一个黑块)</div><div class="line">         */</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; 4; i++) &#123;</div><div class="line">            for (int j = 0; j &lt; 4; j++) &#123;</div><div class="line">                recfs[i][j] = new PiecesRectF();</div><div class="line">                if (j == 1) &#123;</div><div class="line"></div><div class="line">                    if (recfs[i][j - 1].getType() == PiecesRectF.BLAKE || recfs[i][j - 1].getType() == PiecesRectF.START) &#123;</div><div class="line">                        recfs[i][j].setType(PiecesRectF.WRITE);</div><div class="line">                    &#125;</div><div class="line">                &#125; else if (j == 3) &#123;</div><div class="line">                    if (recfs[i][j - 1].getType() == PiecesRectF.BLAKE || recfs[i][j - 1].getType() == PiecesRectF.START) &#123;</div><div class="line">                        recfs[i][j].setType(PiecesRectF.WRITE);</div><div class="line">                    &#125;</div><div class="line">                    if (recfs[i][j - 2].getType() == PiecesRectF.WRITE &amp;&amp; recfs[i][j - 3].getType() == PiecesRectF.WRITE) &#123;</div><div class="line">                        recfs[i][j].setType(PiecesRectF.BLAKE);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;//创建第五行的数据，只需要一个类型为开始的矩形，其他的都是白色</div><div class="line">        for (int i = 0; i &lt; 4; i++) &#123;</div><div class="line">            recfs[4][i]= new PiecesRectF(true);</div><div class="line">            if(i==1)&#123;</div><div class="line">                recfs[4][i].setType(PiecesRectF.START);</div><div class="line">            &#125;else &#123;</div><div class="line">                recfs[4][i].setType(PiecesRectF.WRITE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>初始化好了矩形框，接下来就是绘制矩形框绘制的时候由于要保持界面只呈现四行四列的黑白快，并且界面是从上往下滑动，所以我们初始化的时候将第一行的矩形框根据左右上下的设置将其基本是绘制成了一条线，因此用户看见的第一行矩形框其实就是第二行矩形框，下面是重写OnDraw方法根据二位数据里面矩形框的类型来绘制:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> * 绘制矩形框</div><div class="line"> *</div><div class="line"> * @param canvas</div><div class="line"> */</div><div class="line">private void drawRects(Canvas canvas) &#123;</div><div class="line">    int w = getWidth() / 4;</div><div class="line">    int h = getHeight() / 4;</div><div class="line">    if (isGameOver) &#123;</div><div class="line">        if(onBalckCheckListener !=null)&#123;</div><div class="line">            onBalckCheckListener.gameOver();</div><div class="line">        &#125;</div><div class="line">        isGameOver = false;</div><div class="line">    &#125;</div><div class="line">    for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">        for (int j = 0; j &lt; 4; j++) &#123;</div><div class="line">            recfs[i][j].left = w * j;</div><div class="line">            recfs[i][j].right = w * (j + 1);</div><div class="line">            recfs[i][j].bottom = topRectHeight + i * h;</div><div class="line">            recfs[i][j].top = recfs[i][j].bottom - h;</div><div class="line">            paint.setStyle(Paint.Style.FILL);//设置画笔为填充整个矩形</div><div class="line">            if (recfs[i][j].getType() == PiecesRectF.WRITE) &#123;</div><div class="line"></div><div class="line">                paint.setColor(Color.WHITE);</div><div class="line">                canvas.drawRect(recfs[i][j], paint);</div><div class="line"></div><div class="line">            &#125; else if (recfs[i][j].getType() == PiecesRectF.BLAKE) &#123;</div><div class="line"></div><div class="line">                paint.setColor(Color.BLACK);</div><div class="line">                canvas.drawRect(recfs[i][j], paint);</div><div class="line"></div><div class="line">            &#125; else if (recfs[i][j].getType() == PiecesRectF.BLUE) &#123;</div><div class="line"></div><div class="line">                paint.setColor(Color.BLUE);</div><div class="line">                canvas.drawRect(recfs[i][j], paint);</div><div class="line"></div><div class="line">            &#125; else if (recfs[i][j].getType() == PiecesRectF.RED) &#123;</div><div class="line"></div><div class="line">                paint.setColor(Color.RED);</div><div class="line">                canvas.drawRect(recfs[i][j], paint);</div><div class="line"></div><div class="line">            &#125; else if (recfs[i][j].getType() == PiecesRectF.START) &#123;</div><div class="line"></div><div class="line">                paint.setColor(Color.BLACK);</div><div class="line">                canvas.drawRect(recfs[i][j], paint);</div><div class="line"></div><div class="line">                //在绘制文字</div><div class="line">                paint.setColor(Color.parseColor(&quot;#ffffff&quot;));</div><div class="line">                paint.setTextAlign(Paint.Align.CENTER);</div><div class="line">                paint.setTextSize(50);</div><div class="line"></div><div class="line">                String start = &quot;开始&quot;;</div><div class="line">                Rect bounds = new Rect();</div><div class="line">                paint.getTextBounds(start, 0, start.length(), bounds);</div><div class="line">                float x = recfs[i][j].left / 2 + recfs[i][j].right / 2;</div><div class="line">                float y = recfs[i][j].top / 2 + recfs[i][j].bottom / 2 + bounds.bottom / 2 - bounds.top / 2;</div><div class="line">                canvas.drawText(start, x, y, paint);</div><div class="line">            &#125;</div><div class="line">            /**</div><div class="line">             * 绘制边框</div><div class="line">             */</div><div class="line">            paint.setStyle(Paint.Style.STROKE);</div><div class="line">            paint.setColor(Color.parseColor(&quot;#cccccc&quot;));</div><div class="line">            paint.setStrokeWidth(3);</div><div class="line">            canvas.drawRect(recfs[i][j], paint);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到由于topRectHeight的初始化为0，所以绘制的第一行在界面看不见，所以我们可以根据不断增加该值之后的绘制实现向下滑动，绘制结果如下:</p>
<p><img src="http://img.blog.csdn.net/20170503143912052?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHV3ZWljaGVuZzI0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>好了，绘制成功喽，下面就是对它每个矩形点击的监听处理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        int index  =  event.getActionIndex();</div><div class="line">        switch (event.getActionMasked())&#123;</div><div class="line">            case ACTION_DOWN:</div><div class="line">            case MotionEvent.ACTION_POINTER_DOWN:&#123;</div><div class="line">                int id = event.getPointerId(index);</div><div class="line">                //判断点击的是那个矩形块</div><div class="line">                for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">                    for (int j = 0; j &lt; 4; j++) &#123;</div><div class="line">                        PiecesRectF f = recfs[i][j];</div><div class="line">                        if (event.getX() &gt; f.left &amp;&amp; event.getX() &lt; f.right</div><div class="line">                                &amp;&amp; event.getY() &lt; f.bottom &amp;&amp; event.getY() &gt; f.top) &#123;</div><div class="line">                            selectRecfs.put(id, f);</div><div class="line">                            if (f.getType() == PiecesRectF.BLAKE) &#123;</div><div class="line">                                f.setType(PiecesRectF.BLUE);</div><div class="line">                                score++;</div><div class="line">                            &#125; else if (f.getType() == PiecesRectF.WRITE) &#123;</div><div class="line">                                f.setType(PiecesRectF.RED);</div><div class="line">                                isGameOver = true;</div><div class="line">                                postInvalidate();</div><div class="line">                            &#125; else if (f.getType() == PiecesRectF.START) &#123;</div><div class="line">                                f.setType(PiecesRectF.BLUE);</div><div class="line">                                startThread();</div><div class="line">                            &#125;</div><div class="line">                            if(onBalckCheckListener !=null)&#123;</div><div class="line">                                onBalckCheckListener.score(score);</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">            case MotionEvent.ACTION_POINTER_UP: &#123;</div><div class="line">                int id = event.getPointerId(index);</div><div class="line">                PiecesRectF f = selectRecfs.get(id, null);//得到某个手指选中的方块</div><div class="line">                if (f != null &amp;&amp; f.getType() == PiecesRectF.BLUE) &#123;</div><div class="line">                    //手指抬起后，将蓝色重新变红</div><div class="line">                    f.setType(PiecesRectF.WRITE);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        return true;//事件终止传递</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在事件处理中对矩形的类型进行判断处理，将点击的矩形保存在SparseArray数组中，如果点击的是开始,将开启一个线程对矩形数组和检查是否有黑框漏点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 开启线程不断的对界面进行绘制</div><div class="line">     */</div><div class="line">    private void startThread() &#123;</div><div class="line"></div><div class="line">        new Thread()&#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line"></div><div class="line">                while (true) &#123;</div><div class="line">                    /**</div><div class="line">                     * 判断是否含有黑块接触屏幕底端</div><div class="line">                     */</div><div class="line">                    if(topRectHeight&gt;0)&#123;</div><div class="line">                        if(checkHasBlack())&#123;</div><div class="line">                            isGameOver = true;</div><div class="line">                            postInvalidate();</div><div class="line">                            return;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    topRectHeight += getSpeed();//固定的矩形下滑速度</div><div class="line">                    if(isGameOver)&#123;</div><div class="line">                        return;</div><div class="line">                    &#125;</div><div class="line">                    if (topRectHeight &gt; getHeight() / 4) &#123;//如果顶层的方块高度超出清零</div><div class="line">                        topRectHeight = 0;</div><div class="line">                        updateView();//更新矩形块</div><div class="line">                    &#125;</div><div class="line">                    try &#123;</div><div class="line">                        sleep(15);</div><div class="line">                    &#125; catch (InterruptedException e) &#123;</div><div class="line">                        e.printStackTrace();</div><div class="line">                    &#125;</div><div class="line">                    postInvalidate();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 检查最后一行是否含有黑块</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private Boolean checkHasBlack() &#123;</div><div class="line">        Boolean hasBlack = false;</div><div class="line">        for (int i = 0; i &lt; 4; i++) &#123;</div><div class="line">            if (recfs[4][i].getType() == PiecesRectF.BLAKE||recfs[4][i].getType() == PiecesRectF.START)&#123;</div><div class="line">                recfs[4][i].setType(PiecesRectF.RED);</div><div class="line">                hasBlack = true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return hasBlack;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 从倒数第二行开始跟新到未出现的第一行</div><div class="line">     */</div><div class="line">    private void updateView()&#123;</div><div class="line"></div><div class="line">        for (int i = 4; i &gt;=0; i--) &#123;</div><div class="line">            for (int j = 0; j &lt; 4; j++) &#123;</div><div class="line">                if(i==0)&#123;</div><div class="line">                    recfs[i][j] = new PiecesRectF();</div><div class="line">                    if (j == 1)&#123;</div><div class="line">                        if (recfs[i][j-1].getType() == PiecesRectF.BLAKE)</div><div class="line">                            recfs[i][j].setType(PiecesRectF.WRITE);</div><div class="line">                    &#125;else if (j == 3)&#123;</div><div class="line">                        if (recfs[i][j-1].getType() == PiecesRectF.BLAKE)</div><div class="line">                            recfs[i][j].setType(PiecesRectF.WRITE);</div><div class="line">                        else if (recfs[i][j-2].getType() == PiecesRectF.WRITE &amp;&amp;</div><div class="line">                                recfs[i][j-3].getType() == PiecesRectF.WRITE)</div><div class="line">                            recfs[i][j].setType(PiecesRectF.BLAKE);</div><div class="line">                    &#125;</div><div class="line">                &#125;else&#123;</div><div class="line">                    recfs[i][j] = recfs[i-1][j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>创建一个接口来监听分数和游戏是否结束：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">    * 重新开始游戏</div><div class="line">    */</div><div class="line">   public void restart()&#123;</div><div class="line">       isGameOver = false;</div><div class="line">       topRectHeight= 0;//顶层高度归零</div><div class="line">       score = 0;//分数归零</div><div class="line">       onBalckCheckListener.score(score);</div><div class="line">       initRect();//重新初始化</div><div class="line">       invalidate();//再次绘制</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   public interface OnBalckCheckListener&#123;</div><div class="line">       void score(int score);</div><div class="line">       void gameOver();</div><div class="line">   &#125;</div><div class="line">   private OnBalckCheckListener onBalckCheckListener;</div><div class="line"></div><div class="line">   public void setOnBalckCheckListener(OnBalckCheckListener onBalckCheckListener)&#123;</div><div class="line">       this.onBalckCheckListener = onBalckCheckListener;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>ok，核心代码就是这样<a href="https://github.com/luweicheng24/ClickWhiteBlock" target="_blank" rel="external">Github源码下载</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章通过自定义ViewGroup实现前段时间挺火的一个游戏——别踩白块。好了先看一下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20170503141750007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHV3ZWljaGVuZzI0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://luweicheng24.github.io/categories/Android/"/>
    
    
      <category term="自定义ViewGroup" scheme="https://luweicheng24.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup/"/>
    
  </entry>
  
  <entry>
    <title>自定义具有拉伸阻尼效果的ScrollerView</title>
    <link href="https://luweicheng24.github.io/2017/08/21/first/"/>
    <id>https://luweicheng24.github.io/2017/08/21/first/</id>
    <published>2017-08-21T02:54:19.000Z</published>
    <updated>2017-08-21T04:01:55.585Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>引言<br>一切的自定义都是来自于需求，而在项目开发中由于界面条目太多，所以自然而然的使用到了ScrollerView，当把效果给产品经理的时候呢，ios和Android的效果完全不一样，ios自带的上下拉伸回弹的效果，而Android没有，所以自定义一个具有拉伸效果的ScrollerView迫在眉睫啊.</p>
</blockquote>
<a id="more"></a>
<p>首先来看一下效果图，妹子很漂亮，但是注意重点！！！</p>
<p><img src="http://img.blog.csdn.net/20170722211027420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHV3ZWljaGVuZzI0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>好了，下面进入正题，通过继承ScrollerView来进行相关滑动回弹的效果实现，先来定义几个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private View childView;// 子View（ScrollerView的唯一子类）</div><div class="line">private int y;// 点击时y坐标</div><div class="line">private Rect rect = new Rect();// 矩形(用来保存inner的初始状态，判断是够需要动画回弹效果)</div></pre></td></tr></table></figure>
<p>注释打的也很清楚，然后我们先在该ScrollerView的xml布局加载完成后获取ScrollerView的唯一子布局赋值给上面定义的childView：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 在xml布局绘制为界面完成时调用，</div><div class="line">     * 获取ScrollerView中唯一的直系子布局（ScrollerView中不许包含一层ViewGroup，有且只有一个）</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void onFinishInflate() &#123;</div><div class="line">        if (getChildCount() &gt; 0) &#123;</div><div class="line">            childView = getChildAt(0);</div><div class="line">        &#125;</div><div class="line">        super.onFinishInflate();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面就是处理Touch事件了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * touch 事件处理</div><div class="line">     **/</div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</div><div class="line">        if (childView != null) &#123;</div><div class="line">           handleTouchEvent(ev);</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 触摸事件</div><div class="line">     *</div><div class="line">     * @param ev</div><div class="line">     */</div><div class="line">    public void handleTouchEvent(MotionEvent ev) &#123;</div><div class="line">        int action = ev.getAction();</div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                y = (int) ev.getY();//按下的时候获取到y坐标</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                int nowY = (int) ev.getY(); // 移动时的实时y坐标</div><div class="line">                int delayY = y - nowY;  // 移动时的间隔</div><div class="line">                y = nowY;  // 将本次移动结束时的y坐标赋值给下次移动的起始坐标（也就是nowY）</div><div class="line">                if (isNeedMove()) &#123;</div><div class="line">                    if (rect.isEmpty()) &#123;</div><div class="line">                        //rect保存childView的初始位置信息</div><div class="line">                        rect.set(childView.getLeft(), childView.getTop(), childView.getRight(), childView.getBottom());</div><div class="line">                    &#125;</div><div class="line">                    //移动布局（屏幕移动的距离等于手指滑动距离的一般）</div><div class="line">                    childView.layout(childView.getLeft(), childView.getTop() - delayY / 2, childView.getRight(), childView.getBottom() - delayY / 2);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                if (isNeedAnimation()) &#123;// 判断rect是否为空，也就是是否被重置了</div><div class="line">                    startAnim();//开始回弹动画</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于Touch事件的处理，我注释说的应该很清楚，但是里面有需要调用的四个方法：</p>
<ul>
<li>判断布局是否需要移动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   *  判断布局是否需要移动</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  private boolean isNeedMove() &#123;</div><div class="line">      int offset = childView.getMeasuredHeight() - getHeight();</div><div class="line">      int scrollY = getScrollY();</div><div class="line">      // 0是顶部，后面那个是底部（需要仔细想一下这个过程）</div><div class="line">      if (scrollY == 0 || scrollY == offset) &#123;</div><div class="line">          return true;</div><div class="line">      &#125;</div><div class="line">      return false;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其中childView.getMeasuredHeight()为获取到该布局的实际高度，getHeight是该布局在屏幕中显示的高度，getScrollY()是滑动的时候相对于起始位置的距离。</p>
<ul>
<li>判断rect是否为空</li>
</ul>
<p>在加载布局的时候rect进行了初始化，当确定需要滑动时，再判断一下rect是否为空，因为该rect在布局执行动画回弹之后就会被置空，如果当Scroller顶部对其或者底部对其，未在回弹过程就会将该时刻Scroller的位置信息传入到rect，方便回弹的时候根据rect保存的scrollerview的位置信息完成回弹作用。</p>
<ul>
<li>判断是否需要动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isNeedAnimation() &#123;</div><div class="line">       return !rect.isEmpty();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行动画回弹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void startAnim() &#123;</div><div class="line">      TranslateAnimation anim = new TranslateAnimation(0, 0, childView.getTop(), rect.top);</div><div class="line">      anim.setDuration(200);</div><div class="line">      anim.setInterpolator(new OvershootInterpolator());//加速器</div><div class="line">      childView.startAnimation(anim);</div><div class="line">      // 将inner布局重新回到起始位置</div><div class="line">      childView.layout(rect.left, rect.top, rect.right, rect.bottom);</div><div class="line">      rect.setEmpty();</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在执行完动画回弹后即ScrollerView回归了原始状态，于是rect也就置空，方便下一次继续记录，好了，下面直接贴一份完整代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">import android.content.Context;</div><div class="line">import android.graphics.Rect;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.MotionEvent;</div><div class="line">import android.view.View;</div><div class="line">import android.view.animation.OvershootInterpolator;</div><div class="line">import android.view.animation.TranslateAnimation;</div><div class="line">import android.widget.ScrollView;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Author   : luweicheng on 2017/7/20 0020 15:15</div><div class="line"> * E-mail   ：1769005961@qq.com</div><div class="line"> * GitHub   : https://github.com/luweicheng24</div><div class="line"> * funcation: 具有拉伸效果的ScrollerView</div><div class="line"> */</div><div class="line"></div><div class="line">public class CustomScroller extends ScrollView &#123;</div><div class="line">    private View childView;// 子View（ScrollerView的唯一子类）</div><div class="line">    private int y;// 点击时y坐标</div><div class="line">    private Rect rect = new Rect();// 矩形(用来保存inner的初始状态，判断是够需要动画回弹效果)</div><div class="line">    public CustomScroller(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 在xml布局绘制为界面完成时调用，</div><div class="line">     * 获取ScrollerView中唯一的直系子布局（ScrollerView中不许包含一层ViewGroup，有且只有一个）</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void onFinishInflate() &#123;</div><div class="line">        if (getChildCount() &gt; 0) &#123;</div><div class="line">            childView = getChildAt(0);</div><div class="line">        &#125;</div><div class="line">        super.onFinishInflate();</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * touch 事件处理</div><div class="line">     **/</div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</div><div class="line">        if (childView != null) &#123;</div><div class="line">           handleTouchEvent(ev);</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 触摸事件</div><div class="line">     *</div><div class="line">     * @param ev</div><div class="line">     */</div><div class="line">    public void handleTouchEvent(MotionEvent ev) &#123;</div><div class="line">        int action = ev.getAction();</div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                y = (int) ev.getY();//按下的时候获取到y坐标</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                int nowY = (int) ev.getY(); // 移动时的实时y坐标</div><div class="line">                int delayY = y - nowY;  // 移动时的间隔</div><div class="line">                y = nowY;  // 将本次移动结束时的y坐标赋值给下次移动的起始坐标（也就是nowY）</div><div class="line">                if (isNeedMove()) &#123;</div><div class="line">                    if (rect.isEmpty()) &#123;</div><div class="line">                        //rect保存childView的初始位置信息</div><div class="line">                        rect.set(childView.getLeft(), childView.getTop(), childView.getRight(), childView.getBottom());</div><div class="line">                    &#125;</div><div class="line">                    //移动布局（屏幕移动的距离等于手指滑动距离的一般）</div><div class="line">                    childView.layout(childView.getLeft(), childView.getTop() - delayY / 2, childView.getRight(), childView.getBottom() - delayY / 2);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                if (isNeedAnimation()) &#123;// 判断rect是否为空，也就是是否被重置了</div><div class="line">                    startAnim();//开始回弹动画</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    private void startAnim() &#123;</div><div class="line">        TranslateAnimation anim = new TranslateAnimation(0, 0, childView.getTop(), rect.top);</div><div class="line">        anim.setDuration(200);</div><div class="line">        anim.setInterpolator(new OvershootInterpolator());//加速器</div><div class="line">        childView.startAnimation(anim);</div><div class="line">        // 将inner布局重新回到起始位置</div><div class="line">        childView.layout(rect.left, rect.top, rect.right, rect.bottom);</div><div class="line">        rect.setEmpty();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     *  判断布局是否需要移动</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean isNeedMove() &#123;</div><div class="line">        int offset = childView.getMeasuredHeight() - getHeight();</div><div class="line">        int scrollY = getScrollY();</div><div class="line">        // 0是顶部，后面那个是底部（需要仔细想一下这个过程）</div><div class="line">        if (scrollY == 0 || scrollY == offset) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    public boolean isNeedAnimation() &#123;</div><div class="line">        return !rect.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有问题，在下面留言，共同探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;引言&lt;br&gt;一切的自定义都是来自于需求，而在项目开发中由于界面条目太多，所以自然而然的使用到了ScrollerView，当把效果给产品经理的时候呢，ios和Android的效果完全不一样，ios自带的上下拉伸回弹的效果，而Android没有，所以自定义一个具有拉伸效果的ScrollerView迫在眉睫啊.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://luweicheng24.github.io/categories/Android/"/>
    
    
      <category term="自定义View" scheme="https://luweicheng24.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>你真的准备好了吗？</title>
    <link href="https://luweicheng24.github.io/2017/08/12/My-New-Post/"/>
    <id>https://luweicheng24.github.io/2017/08/12/My-New-Post/</id>
    <published>2017-08-12T13:27:48.000Z</published>
    <updated>2017-08-21T02:48:05.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h3><blockquote>
<p>如何正确编写markDown</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一篇文章&quot;&gt;&lt;a href=&quot;#第一篇文章&quot; class=&quot;headerlink&quot; title=&quot;第一篇文章&quot;&gt;&lt;/a&gt;第一篇文章&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何正确编写markDown&lt;/p&gt;
&lt;/blockquote&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luweicheng24.github.io/2017/08/12/hello-world/"/>
    <id>https://luweicheng24.github.io/2017/08/12/hello-world/</id>
    <published>2017-08-12T04:26:39.145Z</published>
    <updated>2017-08-12T04:26:39.145Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
