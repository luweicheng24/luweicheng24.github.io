<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芦苇</title>
  <subtitle>芦苇的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://luweicheng24.github.io/"/>
  <updated>2017-08-21T04:01:55.585Z</updated>
  <id>https://luweicheng24.github.io/</id>
  
  <author>
    <name>luweicheng24</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>自定义具有拉伸阻尼效果的ScrollerView</title>
    <link href="https://luweicheng24.github.io/2017/08/21/first/"/>
    <id>https://luweicheng24.github.io/2017/08/21/first/</id>
    <published>2017-08-21T02:54:19.000Z</published>
    <updated>2017-08-21T04:01:55.585Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>引言<br>一切的自定义都是来自于需求，而在项目开发中由于界面条目太多，所以自然而然的使用到了ScrollerView，当把效果给产品经理的时候呢，ios和Android的效果完全不一样，ios自带的上下拉伸回弹的效果，而Android没有，所以自定义一个具有拉伸效果的ScrollerView迫在眉睫啊.</p>
</blockquote>
<a id="more"></a>
<p>首先来看一下效果图，妹子很漂亮，但是注意重点！！！</p>
<p><img src="http://img.blog.csdn.net/20170722211027420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbHV3ZWljaGVuZzI0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>好了，下面进入正题，通过继承ScrollerView来进行相关滑动回弹的效果实现，先来定义几个变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">private View childView;// 子View（ScrollerView的唯一子类）</div><div class="line">private int y;// 点击时y坐标</div><div class="line">private Rect rect = new Rect();// 矩形(用来保存inner的初始状态，判断是够需要动画回弹效果)</div></pre></td></tr></table></figure>
<p>注释打的也很清楚，然后我们先在该ScrollerView的xml布局加载完成后获取ScrollerView的唯一子布局赋值给上面定义的childView：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * 在xml布局绘制为界面完成时调用，</div><div class="line">     * 获取ScrollerView中唯一的直系子布局（ScrollerView中不许包含一层ViewGroup，有且只有一个）</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void onFinishInflate() &#123;</div><div class="line">        if (getChildCount() &gt; 0) &#123;</div><div class="line">            childView = getChildAt(0);</div><div class="line">        &#125;</div><div class="line">        super.onFinishInflate();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>下面就是处理Touch事件了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * touch 事件处理</div><div class="line">     **/</div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</div><div class="line">        if (childView != null) &#123;</div><div class="line">           handleTouchEvent(ev);</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 触摸事件</div><div class="line">     *</div><div class="line">     * @param ev</div><div class="line">     */</div><div class="line">    public void handleTouchEvent(MotionEvent ev) &#123;</div><div class="line">        int action = ev.getAction();</div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                y = (int) ev.getY();//按下的时候获取到y坐标</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                int nowY = (int) ev.getY(); // 移动时的实时y坐标</div><div class="line">                int delayY = y - nowY;  // 移动时的间隔</div><div class="line">                y = nowY;  // 将本次移动结束时的y坐标赋值给下次移动的起始坐标（也就是nowY）</div><div class="line">                if (isNeedMove()) &#123;</div><div class="line">                    if (rect.isEmpty()) &#123;</div><div class="line">                        //rect保存childView的初始位置信息</div><div class="line">                        rect.set(childView.getLeft(), childView.getTop(), childView.getRight(), childView.getBottom());</div><div class="line">                    &#125;</div><div class="line">                    //移动布局（屏幕移动的距离等于手指滑动距离的一般）</div><div class="line">                    childView.layout(childView.getLeft(), childView.getTop() - delayY / 2, childView.getRight(), childView.getBottom() - delayY / 2);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                if (isNeedAnimation()) &#123;// 判断rect是否为空，也就是是否被重置了</div><div class="line">                    startAnim();//开始回弹动画</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>对于Touch事件的处理，我注释说的应该很清楚，但是里面有需要调用的四个方法：</p>
<ul>
<li>判断布局是否需要移动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">   *  判断布局是否需要移动</div><div class="line">   * @return</div><div class="line">   */</div><div class="line">  private boolean isNeedMove() &#123;</div><div class="line">      int offset = childView.getMeasuredHeight() - getHeight();</div><div class="line">      int scrollY = getScrollY();</div><div class="line">      // 0是顶部，后面那个是底部（需要仔细想一下这个过程）</div><div class="line">      if (scrollY == 0 || scrollY == offset) &#123;</div><div class="line">          return true;</div><div class="line">      &#125;</div><div class="line">      return false;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其中childView.getMeasuredHeight()为获取到该布局的实际高度，getHeight是该布局在屏幕中显示的高度，getScrollY()是滑动的时候相对于起始位置的距离。</p>
<ul>
<li>判断rect是否为空</li>
</ul>
<p>在加载布局的时候rect进行了初始化，当确定需要滑动时，再判断一下rect是否为空，因为该rect在布局执行动画回弹之后就会被置空，如果当Scroller顶部对其或者底部对其，未在回弹过程就会将该时刻Scroller的位置信息传入到rect，方便回弹的时候根据rect保存的scrollerview的位置信息完成回弹作用。</p>
<ul>
<li>判断是否需要动画</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public boolean isNeedAnimation() &#123;</div><div class="line">       return !rect.isEmpty();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ul>
<li>执行动画回弹</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">private void startAnim() &#123;</div><div class="line">      TranslateAnimation anim = new TranslateAnimation(0, 0, childView.getTop(), rect.top);</div><div class="line">      anim.setDuration(200);</div><div class="line">      anim.setInterpolator(new OvershootInterpolator());//加速器</div><div class="line">      childView.startAnimation(anim);</div><div class="line">      // 将inner布局重新回到起始位置</div><div class="line">      childView.layout(rect.left, rect.top, rect.right, rect.bottom);</div><div class="line">      rect.setEmpty();</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在执行完动画回弹后即ScrollerView回归了原始状态，于是rect也就置空，方便下一次继续记录，好了，下面直接贴一份完整代码吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">import android.content.Context;</div><div class="line">import android.graphics.Rect;</div><div class="line">import android.util.AttributeSet;</div><div class="line">import android.view.MotionEvent;</div><div class="line">import android.view.View;</div><div class="line">import android.view.animation.OvershootInterpolator;</div><div class="line">import android.view.animation.TranslateAnimation;</div><div class="line">import android.widget.ScrollView;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Author   : luweicheng on 2017/7/20 0020 15:15</div><div class="line"> * E-mail   ：1769005961@qq.com</div><div class="line"> * GitHub   : https://github.com/luweicheng24</div><div class="line"> * funcation: 具有拉伸效果的ScrollerView</div><div class="line"> */</div><div class="line"></div><div class="line">public class CustomScroller extends ScrollView &#123;</div><div class="line">    private View childView;// 子View（ScrollerView的唯一子类）</div><div class="line">    private int y;// 点击时y坐标</div><div class="line">    private Rect rect = new Rect();// 矩形(用来保存inner的初始状态，判断是够需要动画回弹效果)</div><div class="line">    public CustomScroller(Context context, AttributeSet attrs) &#123;</div><div class="line">        super(context, attrs);</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * 在xml布局绘制为界面完成时调用，</div><div class="line">     * 获取ScrollerView中唯一的直系子布局（ScrollerView中不许包含一层ViewGroup，有且只有一个）</div><div class="line">     */</div><div class="line">    @Override</div><div class="line">    protected void onFinishInflate() &#123;</div><div class="line">        if (getChildCount() &gt; 0) &#123;</div><div class="line">            childView = getChildAt(0);</div><div class="line">        &#125;</div><div class="line">        super.onFinishInflate();</div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     * touch 事件处理</div><div class="line">     **/</div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent ev) &#123;</div><div class="line">        if (childView != null) &#123;</div><div class="line">           handleTouchEvent(ev);</div><div class="line">        &#125;</div><div class="line">        return super.onTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /***</div><div class="line">     * 触摸事件</div><div class="line">     *</div><div class="line">     * @param ev</div><div class="line">     */</div><div class="line">    public void handleTouchEvent(MotionEvent ev) &#123;</div><div class="line">        int action = ev.getAction();</div><div class="line">        switch (action) &#123;</div><div class="line">            case MotionEvent.ACTION_DOWN:</div><div class="line">                y = (int) ev.getY();//按下的时候获取到y坐标</div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_MOVE:</div><div class="line">                int nowY = (int) ev.getY(); // 移动时的实时y坐标</div><div class="line">                int delayY = y - nowY;  // 移动时的间隔</div><div class="line">                y = nowY;  // 将本次移动结束时的y坐标赋值给下次移动的起始坐标（也就是nowY）</div><div class="line">                if (isNeedMove()) &#123;</div><div class="line">                    if (rect.isEmpty()) &#123;</div><div class="line">                        //rect保存childView的初始位置信息</div><div class="line">                        rect.set(childView.getLeft(), childView.getTop(), childView.getRight(), childView.getBottom());</div><div class="line">                    &#125;</div><div class="line">                    //移动布局（屏幕移动的距离等于手指滑动距离的一般）</div><div class="line">                    childView.layout(childView.getLeft(), childView.getTop() - delayY / 2, childView.getRight(), childView.getBottom() - delayY / 2);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                break;</div><div class="line">            case MotionEvent.ACTION_UP:</div><div class="line">                if (isNeedAnimation()) &#123;// 判断rect是否为空，也就是是否被重置了</div><div class="line">                    startAnim();//开始回弹动画</div><div class="line">                &#125;</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    private void startAnim() &#123;</div><div class="line">        TranslateAnimation anim = new TranslateAnimation(0, 0, childView.getTop(), rect.top);</div><div class="line">        anim.setDuration(200);</div><div class="line">        anim.setInterpolator(new OvershootInterpolator());//加速器</div><div class="line">        childView.startAnimation(anim);</div><div class="line">        // 将inner布局重新回到起始位置</div><div class="line">        childView.layout(rect.left, rect.top, rect.right, rect.bottom);</div><div class="line">        rect.setEmpty();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    /**</div><div class="line">     *  判断布局是否需要移动</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    private boolean isNeedMove() &#123;</div><div class="line">        int offset = childView.getMeasuredHeight() - getHeight();</div><div class="line">        int scrollY = getScrollY();</div><div class="line">        // 0是顶部，后面那个是底部（需要仔细想一下这个过程）</div><div class="line">        if (scrollY == 0 || scrollY == offset) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    public boolean isNeedAnimation() &#123;</div><div class="line">        return !rect.isEmpty();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果有问题，在下面留言，共同探讨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;引言&lt;br&gt;一切的自定义都是来自于需求，而在项目开发中由于界面条目太多，所以自然而然的使用到了ScrollerView，当把效果给产品经理的时候呢，ios和Android的效果完全不一样，ios自带的上下拉伸回弹的效果，而Android没有，所以自定义一个具有拉伸效果的ScrollerView迫在眉睫啊.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Android" scheme="https://luweicheng24.github.io/categories/Android/"/>
    
    
      <category term="自定义View" scheme="https://luweicheng24.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>你真的准备好了吗？</title>
    <link href="https://luweicheng24.github.io/2017/08/12/My-New-Post/"/>
    <id>https://luweicheng24.github.io/2017/08/12/My-New-Post/</id>
    <published>2017-08-12T13:27:48.000Z</published>
    <updated>2017-08-21T02:48:05.008Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h3><blockquote>
<p>如何正确编写markDown</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一篇文章&quot;&gt;&lt;a href=&quot;#第一篇文章&quot; class=&quot;headerlink&quot; title=&quot;第一篇文章&quot;&gt;&lt;/a&gt;第一篇文章&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;如何正确编写markDown&lt;/p&gt;
&lt;/blockquote&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luweicheng24.github.io/2017/08/12/hello-world/"/>
    <id>https://luweicheng24.github.io/2017/08/12/hello-world/</id>
    <published>2017-08-12T04:26:39.145Z</published>
    <updated>2017-08-12T04:26:39.145Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
</feed>
